документ описывающий библиотеку [[panelflow specification]] вцелом
документ описывающий [[coreflow.core specification]]
документ описывающий технические детали реализации [[coreflow.core technical details]]
документ описывающий [[coreflow.events]]
документ описывающий [[coreflow.render ]](на примере консольного рендерера)
документ описывающий [[coreflow UI]]

[[panelflow diagnostic]]

# Дорожная карта реализации библиотеки PanelFlow

Этот документ представляет собой пошаговый план для LLM-агента по реализации библиотеки `PanelFlow`. Каждый этап — это самодостаточный блок работы с четко определенным контекстом и последовательностью запросов.

## Этап 1: Создание каркаса `panelflow.core`

**Цель**: Создать файловую структуру и все необходимые классы-пустышки для ядра библиотеки. На этом этапе мы не реализуем логику, а только определяем архитектурный скелет.

### 1.1. Контекст для LLM-агента

Перед началом работы предоставьте агенту следующие документы:

- `Техническая спецификация: Слой Ядра (panelflow.core)`
    
- `Событийная модель и встроенные обработчики ядра PanelFlow`
    

### 1.2. Инициирующий промпт

```
Ты — опытный Python-разработчик, специализирующийся на создании гибких фреймворков. Твоя задача — создать каркас для ядра библиотеки PanelFlow. На этом этапе ты должен создать все необходимые файлы и классы, но без внутренней логики. Просто определи их структуру, атрибуты и методы с пустыми телами (используй `pass` или `...`). Работай строго в соответствии с предоставленными спецификациями.
```

### 1.3. Последовательность запросов

1. **Запрос 1**: "Создай файловую структуру для `panelflow.core`."
    
2. **Запрос 2**: "На основе спецификации, создай файл `panelflow/core/components.py` и определи в нем все классы `AbstractWidget` и `AbstractPanel`."
    
3. **Запрос 3**: "Создай файл `panelflow/core/state.py` и определи в нем класс `TreeNode` со всеми полями, включая `children_stacks`."
    
4. **Запрос 4**: "Создай файл `panelflow/core/events.py` и определи в нем все классы событий (входящие и исходящие)."
    
5. **Запрос 5**: "Создай файл `panelflow/core/handlers.py` и определи в нем абстрактный базовый класс `BasePanelHandler`."
    
6. **Запрос 6**: "Создай файл `panelflow/core/application.py` и определи в нем класс `Application` со всеми публичными и внутренними методами, указанными в спецификации. В теле методов используй `pass`."
    

## Этап 2: Загрузка и валидация конфигурации

**Цель**: Реализовать механизм, который загружает `application.json`, проверяет его на корректность и преобразует в объекты `AbstractPanel`.

### 2.1. Контекст для LLM-агента

- Все документы из Этапа 1.
    

### 2.2. Инициирующий промпт

```
Продолжаем работу над ядром PanelFlow. Теперь твоя задача — реализовать надежный загрузчик конфигурации. Ты должен сначала создать JSON Schema для валидации, а затем реализовать метод загрузки в классе Application.
```

### 2.3. Последовательность запросов

1. **Запрос 1**: "Создай детальную JSON Schema для файла `application.json`. Схема должна описывать все панели, виджеты и их свойства, как указано в спецификациях. Удели внимание обязательным полям и типам данных."
    
2. **Запрос 2**: "В классе `Application` реализуй внутренний метод `_load_config(self, path: str)`. Он должен читать файл, валидировать его содержимое с помощью созданной JSON Schema и парсить валидные данные в словарь объектов `AbstractPanel` (`dict[str, AbstractPanel]`). Используй библиотеку `jsonschema`."
    
3. **Запрос 3**: "Теперь реализуй конструктор `__init__` в классе `Application`. Он должен вызывать `_load_config`, а затем выполнять дополнительные проверки целостности: что `entryPanel` существует, что все `target_panel_id` у `PanelLink` корректны, и что все `handler_class_name` присутствуют в `handler_map`. При любой ошибке должна быть сгенерирована соответствующая ошибка."
    

## Этап 3: Реализация стековой навигации и логики виджетов

**Цель**: Реализовать всю сложную логику управления состоянием, включая создание/удаление панелей, вертикальную и горизонтальную навигацию.

### 3.1. Контекст для LLM-агента

- Весь код, созданный на предыдущих этапах.
    
- Все спецификации.
    

### 3.2. Инициирующий промпт

```
Это самый важный этап. Ты должен реализовать внутренние обработчики событий в классе `Application`. Работай методично, реализуя по одному обработчику за раз. Удели особое внимание корректной работе со структурой `TreeNode` и стеками `children_stacks`. Напиши вспомогательные функции для поиска узлов и уничтожения веток, если это необходимо.
```

### 3.3. Последовательность запросов

1. **Запрос 1**: "Реализуй вспомогательные функции: `_get_path_to_active_node()` и `_find_node_by_widget_id()`."
    
2. **Запрос 2**: "Реализуй внутренний обработчик `_handle_horizontal_navigation`."
    
3. **Запрос 3**: "Реализуй внутренний обработчик `_handle_vertical_navigation`. Логика должна точно соответствовать спецификации (перемещение элемента на вершину стека)."
    
4. **Запрос 4**: "Реализуй вспомогательную функцию `_destroy_stack_recursively`, которая рекурсивно удаляет все узлы в стеке и все их дочерние ветки."
    
5. **Запрос 5**: "Реализуй внутренний обработчик `_execute_navigation_down`, который обрабатывает создание новой панели, включая уничтожение старой ветки."
    
6. **Запрос 6**: "Реализуй внутренний обработчик `_handle_widget_submission`, который связывает все вместе: находит узел, обновляет `form_data`, вызывает пользовательский обработчик и запускает навигацию."
    
7. **Запрос 7**: "Реализуй внутренний обработчик `_handle_back_navigation`. Убедись, что он корректно работает со стеками."
    
8. **Запрос 8**: "Наконец, реализуй главный метод `post_event` и систему подписки `subscribe`/`_publish`."
    

## Этап 4: Реализация TUI-рендерера

**Цель**: Создать рабочий, но минималистичный рендерер для терминала, который может отображать состояние ядра и отправлять ему события.

### 4.1. Контекст для LLM-агента

- Готовое и протестированное ядро `panelflow.core`.
    
- Документ `Техническая спецификация: Слой Рендеринга PanelFlow`.
    
- Документ `Детальное описание пользовательского интерфейса PanelFlow`.
    

### 4.2. Инициирующий промпт

```
Теперь, когда ядро готово, твоя задача — создать для него визуальное представление в терминале с помощью библиотеки Textual. Ты будешь создавать слой, который ничего не знает о бизнес-логике, а только слушает события от ядра и рендерит интерфейс, а также отправляет действия пользователя обратно в ядро.
```

### 4.3. Последовательность запросов

1. **Запрос 1**: "Создай файловую структуру для `panelflow.tui`."
    
2. **Запрос 2**: "Реализуй класс `TuiApplication`, который принимает в `__init__` экземпляр `core.Application` и подписывается на его события. Реализуй методы `on_mount`, `on_core_state_change` и `on_core_error`."
    
3. **Запрос 3**: "Реализуй класс `MainScreen`. В нем определи `BINDINGS` для всех навигационных клавиш и соответствующие `action_*` методы, которые будут вызывать `self.core.post_event()`."
    
4. **Запрос 4**: "В классе `MainScreen` создай `widget_factory` и реализуй метод `update_view`. Этот метод должен получать новое дерево состояний, очищать старые панели и рендерить новые на основе пути к активному узлу и состояния стеков."
    
5. **Запрос 5**: "Создай конкретную реализацию виджета, например, `TuiButton`. Этот класс должен наследовать `textual.widgets.Button`, принимать в `__init__` `AbstractButton` и колбэк `post_event_callback`. В методе `on_button_pressed` он должен создавать `WidgetSubmittedEvent` и вызывать колбэк."
    
6. **Запрос 6**: "Создай пример минимального рабочего приложения (`example/run.py`, `example/app.json`, `example/handlers.py`), чтобы можно было запустить и протестировать совместную работу ядра и рендерера."